"use strict";

exports.__esModule = true;
exports["default"] = createTag;

var _utils = require("../utils");

var tagTransformersSymbol = 'COMMON_TAGS_TAG_TRANSFORMERS_SYMBOL';

function isTag(fn) {
  return typeof fn === 'function' && fn[tagTransformersSymbol];
}

function cleanTransformers(transformers) {
  return (0, _utils.flat)(transformers).reduce(function (transformers, transformer) {
    return isTag(transformer) ? [].concat(transformers, transformer[tagTransformersSymbol]) : [].concat(transformers, [transformer]);
  }, []);
}
/**
 * An intermediary template tag that receives a template tag and passes the result of calling the template with the received
 * template tag to our own template tag.
 * @param  {Function}        nextTag          - The received template tag
 * @param  {Array<String>}   template         - The template to process
 * @param  {...*}            ...substitutions - `substitutions` is an array of all substitutions in the template
 * @return {*}                                - The final processed value
 */


function getInterimTag(originalTag, extraTag) {
  return function tag() {
    return originalTag(['', ''], extraTag.apply(void 0, arguments));
  };
}

function getTagCallInfo(transformers) {
  return {
    transformers: transformers,
    context: transformers.map(function (transformer) {
      return transformer.getInitialContext ? transformer.getInitialContext() : {};
    })
  };
}
/**
 * Iterate through each transformer, calling the transformer's specified hook.
 * @param {Array<Function>} transformers - The transformer functions
 * @param {String} hookName              - The name of the hook
 * @param {String} initialString         - The input string
 * @return {String}                      - The final results of applying each transformer
 */


function applyHook0(_ref, hookName, initialString) {
  var transformers = _ref.transformers,
      context = _ref.context;
  return transformers.reduce(function (result, transformer, index) {
    return transformer[hookName] ? transformer[hookName](result, context[index]) : result;
  }, initialString);
}
/**
 * Iterate through each transformer, calling the transformer's specified hook.
 * @param {Array<Function>} transformers - The transformer functions
 * @param {String} hookName              - The name of the hook
 * @param {String} initialString         - The input string
 * @param {*} arg1                       - An additional argument passed to the hook
 * @return {String}                      - The final results of applying each transformer
 */


function applyHook1(_ref2, hookName, initialString, arg1) {
  var transformers = _ref2.transformers,
      context = _ref2.context;
  return transformers.reduce(function (result, transformer, index) {
    return transformer[hookName] ? transformer[hookName](result, arg1, context[index]) : result;
  }, initialString);
}
/**
 * Consumes a pipeline of composable transformer plugins and produces a template tag.
 * @param  {...Object} [...rawTransformers] - An array or arguments list of transformers
 * @return {Function}                       - A template tag
 */


function createTag() {
  for (var _len = arguments.length, rawTransformers = new Array(_len), _key = 0; _key < _len; _key++) {
    rawTransformers[_key] = arguments[_key];
  }

  var transformers = cleanTransformers(rawTransformers);

  function tag(strings) {
    for (var _len2 = arguments.length, expressions = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      expressions[_key2 - 1] = arguments[_key2];
    }

    if (typeof strings === 'function') {
      // if the first argument passed is a function, assume it is a template tag and return
      // an intermediary tag that processes the template using the aforementioned tag, passing the
      // result to our tag
      return getInterimTag(tag, strings);
    }

    if (!Array.isArray(strings)) {
      return tag([strings]);
    }

    var tagCallInfo = getTagCallInfo(transformers); // if the first argument is an array, return a transformed end result of processing the template with our tag

    var processedTemplate = strings.map(function (string) {
      return applyHook0(tagCallInfo, 'onString', string);
    }).reduce(function (result, string, index) {
      return ''.concat(result, applyHook1(tagCallInfo, 'onSubstitution', expressions[index - 1], result), string);
    });
    return applyHook0(tagCallInfo, 'onEndResult', processedTemplate);
  }

  tag[tagTransformersSymbol] = transformers;
  return tag;
}

module.exports = exports.default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jcmVhdGVUYWcvY3JlYXRlVGFnLmpzIl0sIm5hbWVzIjpbInRhZ1RyYW5zZm9ybWVyc1N5bWJvbCIsImlzVGFnIiwiZm4iLCJjbGVhblRyYW5zZm9ybWVycyIsInRyYW5zZm9ybWVycyIsInJlZHVjZSIsInRyYW5zZm9ybWVyIiwiZ2V0SW50ZXJpbVRhZyIsIm9yaWdpbmFsVGFnIiwiZXh0cmFUYWciLCJ0YWciLCJnZXRUYWdDYWxsSW5mbyIsImNvbnRleHQiLCJtYXAiLCJnZXRJbml0aWFsQ29udGV4dCIsImFwcGx5SG9vazAiLCJob29rTmFtZSIsImluaXRpYWxTdHJpbmciLCJyZXN1bHQiLCJpbmRleCIsImFwcGx5SG9vazEiLCJhcmcxIiwiY3JlYXRlVGFnIiwicmF3VHJhbnNmb3JtZXJzIiwic3RyaW5ncyIsImV4cHJlc3Npb25zIiwiQXJyYXkiLCJpc0FycmF5IiwidGFnQ2FsbEluZm8iLCJwcm9jZXNzZWRUZW1wbGF0ZSIsInN0cmluZyIsImNvbmNhdCJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7QUFFQSxJQUFNQSxxQkFBcUIsR0FBRyxxQ0FBOUI7O0FBRUEsU0FBU0MsS0FBVCxDQUFlQyxFQUFmLEVBQW1CO0FBQ2pCLFNBQU8sT0FBT0EsRUFBUCxLQUFjLFVBQWQsSUFBNEJBLEVBQUUsQ0FBQ0YscUJBQUQsQ0FBckM7QUFDRDs7QUFFRCxTQUFTRyxpQkFBVCxDQUEyQkMsWUFBM0IsRUFBeUM7QUFDdkMsU0FBTyxpQkFBS0EsWUFBTCxFQUFtQkMsTUFBbkIsQ0FDTCxVQUFDRCxZQUFELEVBQWVFLFdBQWY7QUFBQSxXQUNFTCxLQUFLLENBQUNLLFdBQUQsQ0FBTCxhQUNRRixZQURSLEVBQ3lCRSxXQUFXLENBQUNOLHFCQUFELENBRHBDLGNBRVFJLFlBRlIsR0FFc0JFLFdBRnRCLEVBREY7QUFBQSxHQURLLEVBS0wsRUFMSyxDQUFQO0FBT0Q7QUFFRDs7Ozs7Ozs7OztBQVFBLFNBQVNDLGFBQVQsQ0FBdUJDLFdBQXZCLEVBQW9D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SyxHQUFHLENBQVQsQ0FISCxFQUlSRCxNQUpRLENBRlosRUFRRVksTUFSRixDQURNO0FBQUEsS0FGZ0IsQ0FBMUI7QUFlQSxXQUFPZixVQUFVLENBQUNhLFdBQUQsRUFBYyxhQUFkLEVBQTZCQyxpQkFBN0IsQ0FBakI7QUFDRDs7QUFFRG5CLEVBQUFBLEdBQUcsQ0FBQ1YscUJBQUQsQ0FBSCxHQUE2QkksWUFBN0I7QUFFQSxTQUFPTSxHQUFQO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBmbGF0IH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5jb25zdCB0YWdUcmFuc2Zvcm1lcnNTeW1ib2wgPSAnQ09NTU9OX1RBR1NfVEFHX1RSQU5TRk9STUVSU19TWU1CT0wnO1xuXG5mdW5jdGlvbiBpc1RhZyhmbikge1xuICByZXR1cm4gdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nICYmIGZuW3RhZ1RyYW5zZm9ybWVyc1N5bWJvbF07XG59XG5cbmZ1bmN0aW9uIGNsZWFuVHJhbnNmb3JtZXJzKHRyYW5zZm9ybWVycykge1xuICByZXR1cm4gZmxhdCh0cmFuc2Zvcm1lcnMpLnJlZHVjZShcbiAgICAodHJhbnNmb3JtZXJzLCB0cmFuc2Zvcm1lcikgPT5cbiAgICAgIGlzVGFnKHRyYW5zZm9ybWVyKVxuICAgICAgICA/IFsuLi50cmFuc2Zvcm1lcnMsIC4uLnRyYW5zZm9ybWVyW3RhZ1RyYW5zZm9ybWVyc1N5bWJvbF1dXG4gICAgICAgIDogWy4uLnRyYW5zZm9ybWVycywgdHJhbnNmb3JtZXJdLFxuICAgIFtdLFxuICApO1xufVxuXG4vKipcbiAqIEFuIGludGVybWVkaWFyeSB0ZW1wbGF0ZSB0YWcgdGhhdCByZWNlaXZlcyBhIHRlbXBsYXRlIHRhZyBhbmQgcGFzc2VzIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgdGVtcGxhdGUgd2l0aCB0aGUgcmVjZWl2ZWRcbiAqIHRlbXBsYXRlIHRhZyB0byBvdXIgb3duIHRlbXBsYXRlIHRhZy5cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSAgICAgICAgbmV4dFRhZyAgICAgICAgICAtIFRoZSByZWNlaXZlZCB0ZW1wbGF0ZSB0YWdcbiAqIEBwYXJhbSAge0FycmF5PFN0cmluZz59ICAgdGVtcGxhdGUgICAgICAgICAtIFRoZSB0ZW1wbGF0ZSB0byBwcm9jZXNzXG4gKiBAcGFyYW0gIHsuLi4qfSAgICAgICAgICAgIC4uLnN1YnN0aXR1dGlvbnMgLSBgc3Vic3RpdHV0aW9uc2AgaXMgYW4gYXJyYXkgb2YgYWxsIHN1YnN0aXR1dGlvbnMgaW4gdGhlIHRlbXBsYXRlXG4gKiBAcmV0dXJuIHsqfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBUaGUgZmluYWwgcHJvY2Vzc2VkIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIGdldEludGVyaW1UYWcob3JpZ2luYWxUYWcsIGV4dHJhVGFnKSB7XG4gIHJldHVybiBmdW5jdGlvbiB0YWcoLi4uYXJncykge1xuICAgIHJldHVybiBvcmlnaW5hbFRhZyhbJycsICcnXSwgZXh0cmFUYWcoLi4uYXJncykpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRUYWdDYWxsSW5mbyh0cmFuc2Zvcm1lcnMpIHtcbiAgcmV0dXJuIHtcbiAgICB0cmFuc2Zvcm1lcnMsXG4gICAgY29udGV4dDogdHJhbnNmb3JtZXJzLm1hcCh0cmFuc2Zvcm1lciA9PlxuICAgICAgdHJhbnNmb3JtZXIuZ2V0SW5pdGlhbENvbnRleHQgPyB0cmFuc2Zvcm1lci5nZXRJbml0aWFsQ29udGV4dCgpIDoge30sXG4gICAgKSxcbiAgfTtcbn1cblxuLyoqXG4gKiBJdGVyYXRlIHRocm91Z2ggZWFjaCB0cmFuc2Zvcm1lciwgY2FsbGluZyB0aGUgdHJhbnNmb3JtZXIncyBzcGVjaWZpZWQgaG9vay5cbiAqIEBwYXJhbSB7QXJyYXk8RnVuY3Rpb24+fSB0cmFuc2Zvcm1lcnMgLSBUaGUgdHJhbnNmb3JtZXIgZnVuY3Rpb25zXG4gKiBAcGFyYW0ge1N0cmluZ30gaG9va05hbWUgICAgICAgICAgICAgIC0gVGhlIG5hbWUgb2YgdGhlIGhvb2tcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbml0aWFsU3RyaW5nICAgICAgICAgLSBUaGUgaW5wdXQgc3RyaW5nXG4gKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgICAgICAgICAgICAgIC0gVGhlIGZpbmFsIHJlc3VsdHMgb2YgYXBwbHlpbmcgZWFjaCB0cmFuc2Zvcm1lclxuICovXG5mdW5jdGlvbiBhcHBseUhvb2swKHsgdHJhbnNmb3JtZXJzLCBjb250ZXh0IH0sIGhvb2tOYW1lLCBpbml0aWFsU3RyaW5nKSB7XG4gIHJldHVybiB0cmFuc2Zvcm1lcnMucmVkdWNlKFxuICAgIChyZXN1bHQsIHRyYW5zZm9ybWVyLCBpbmRleCkgPT5cbiAgICAgIHRyYW5zZm9ybWVyW2hvb2tOYW1lXVxuICAgICAgICA/IHRyYW5zZm9ybWVyW2hvb2tOYW1lXShyZXN1bHQsIGNvbnRleHRbaW5kZXhdKVxuICAgICAgICA6IHJlc3VsdCxcbiAgICBpbml0aWFsU3RyaW5nLFxuICApO1xufVxuXG4vKipcbiAqIEl0ZXJhdGUgdGhyb3VnaCBlYWNoIHRyYW5zZm9ybWVyLCBjYWxsaW5nIHRoZSB0cmFuc2Zvcm1lcidzIHNwZWNpZmllZCBob29rLlxuICogQHBhcmFtIHtBcnJheTxGdW5jdGlvbj59IHRyYW5zZm9ybWVycyAtIFRoZSB0cmFuc2Zvcm1lciBmdW5jdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBob29rTmFtZSAgICAgICAgICAgICAgLSBUaGUgbmFtZSBvZiB0aGUgaG9va1xuICogQHBhcmFtIHtTdHJpbmd9IGluaXRpYWxTdHJpbmcgICAgICAgICAtIFRoZSBpbnB1dCBzdHJpbmdcbiAqIEBwYXJhbSB7Kn0gYXJnMSAgICAgICAgICAgICAgICAgICAgICAgLSBBbiBhZGRpdGlvbmFsIGFyZ3VtZW50IHBhc3NlZCB0byB0aGUgaG9va1xuICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICAgICAgICAgICAgICAtIFRoZSBmaW5hbCByZXN1bHRzIG9mIGFwcGx5aW5nIGVhY2ggdHJhbnNmb3JtZXJcbiAqL1xuZnVuY3Rpb24gYXBwbHlIb29rMSh7IHRyYW5zZm9ybWVycywgY29udGV4dCB9LCBob29rTmFtZSwgaW5pdGlhbFN0cmluZywgYXJnMSkge1xuICByZXR1cm4gdHJhbnNmb3JtZXJzLnJlZHVjZShcbiAgICAocmVzdWx0LCB0cmFuc2Zvcm1lciwgaW5kZXgpID0+XG4gICAgICB0cmFuc2Zvcm1lcltob29rTmFtZV1cbiAgICAgICAgPyB0cmFuc2Zvcm1lcltob29rTmFtZV0ocmVzdWx0LCBhcmcxLCBjb250ZXh0W2luZGV4XSlcbiAgICAgICAgOiByZXN1bHQsXG4gICAgaW5pdGlhbFN0cmluZyxcbiAgKTtcbn1cblxuLyoqXG4gKiBDb25zdW1lcyBhIHBpcGVsaW5lIG9mIGNvbXBvc2FibGUgdHJhbnNmb3JtZXIgcGx1Z2lucyBhbmQgcHJvZHVjZXMgYSB0ZW1wbGF0ZSB0YWcuXG4gKiBAcGFyYW0gIHsuLi5PYmplY3R9IFsuLi5yYXdUcmFuc2Zvcm1lcnNdIC0gQW4gYXJyYXkgb3IgYXJndW1lbnRzIGxpc3Qgb2YgdHJhbnNmb3JtZXJzXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gICAgICAgICAgICAgICAgICAgICAgIC0gQSB0ZW1wbGF0ZSB0YWdcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlVGFnKC4uLnJhd1RyYW5zZm9ybWVycykge1xuICBjb25zdCB0cmFuc2Zvcm1lcnMgPSBjbGVhblRyYW5zZm9ybWVycyhyYXdUcmFuc2Zvcm1lcnMpO1xuXG4gIGZ1bmN0aW9uIHRhZyhzdHJpbmdzLCAuLi5leHByZXNzaW9ucykge1xuICAgIGlmICh0eXBlb2Ygc3RyaW5ncyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gaWYgdGhlIGZpcnN0IGFyZ3VtZW50IHBhc3NlZCBpcyBhIGZ1bmN0aW9uLCBhc3N1bWUgaXQgaXMgYSB0ZW1wbGF0ZSB0YWcgYW5kIHJldHVyblxuICAgICAgLy8gYW4gaW50ZXJtZWRpYXJ5IHRhZyB0aGF0IHByb2Nlc3NlcyB0aGUgdGVtcGxhdGUgdXNpbmcgdGhlIGFmb3JlbWVudGlvbmVkIHRhZywgcGFzc2luZyB0aGVcbiAgICAgIC8vIHJlc3VsdCB0byBvdXIgdGFnXG4gICAgICByZXR1cm4gZ2V0SW50ZXJpbVRhZyh0YWcsIHN0cmluZ3MpO1xuICAgIH1cblxuICAgIGlmICghQXJyYXkuaXNBcnJheShzdHJpbmdzKSkge1xuICAgICAgcmV0dXJuIHRhZyhbc3RyaW5nc10pO1xuICAgIH1cblxuICAgIGNvbnN0IHRhZ0NhbGxJbmZvID0gZ2V0VGFnQ2FsbEluZm8odHJhbnNmb3JtZXJzKTtcblxuICAgIC8vIGlmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhbiBhcnJheSwgcmV0dXJuIGEgdHJhbnNmb3JtZWQgZW5kIHJlc3VsdCBvZiBwcm9jZXNzaW5nIHRoZSB0ZW1wbGF0ZSB3aXRoIG91ciB0YWdcbiAgICBjb25zdCBwcm9jZXNzZWRUZW1wbGF0ZSA9IHN0cmluZ3NcbiAgICAgIC5tYXAoc3RyaW5nID0+IGFwcGx5SG9vazAodGFnQ2FsbEluZm8sICdvblN0cmluZycsIHN0cmluZykpXG4gICAgICAucmVkdWNlKChyZXN1bHQsIHN0cmluZywgaW5kZXgpID0+XG4gICAgICAgICcnLmNvbmNhdChcbiAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgYXBwbHlIb29rMShcbiAgICAgICAgICAgIHRhZ0NhbGxJbmZvLFxuICAgICAgICAgICAgJ29uU3Vic3RpdHV0aW9uJyxcbiAgICAgICAgICAgIGV4cHJlc3Npb25zW2luZGV4IC0gMV0sXG4gICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgKSxcbiAgICAgICAgICBzdHJpbmcsXG4gICAgICAgICksXG4gICAgICApO1xuXG4gICAgcmV0dXJuIGFwcGx5SG9vazAodGFnQ2FsbEluZm8sICdvbkVuZFJlc3VsdCcsIHByb2Nlc3NlZFRlbXBsYXRlKTtcbiAgfVxuXG4gIHRhZ1t0YWdUcmFuc2Zvcm1lcnNTeW1ib2xdID0gdHJhbnNmb3JtZXJzO1xuXG4gIHJldHVybiB0YWc7XG59XG4iXX0=