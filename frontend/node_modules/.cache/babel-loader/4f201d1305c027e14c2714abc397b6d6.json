{"ast":null,"code":"import { unstable_ownerWindow as ownerWindow, unstable_ownerDocument as ownerDocument, unstable_getScrollbarSize as getScrollbarSize } from '@mui/utils'; // Is a vertical scrollbar displayed?\n\nfunction isOverflowing(container) {\n  const doc = ownerDocument(container);\n\n  if (doc.body === container) {\n    return ownerWindow(container).innerWidth > doc.documentElement.clientWidth;\n  }\n\n  return container.scrollHeight > container.clientHeight;\n}\n\nexport function ariaHidden(element, show) {\n  if (show) {\n    element.setAttribute('aria-hidden', 'true');\n  } else {\n    element.removeAttribute('aria-hidden');\n  }\n}\n\nfunction getPaddingRight(element) {\n  return parseInt(ownerWindow(element).getComputedStyle(element).paddingRight, 10) || 0;\n}\n\nfunction ariaHiddenSiblings(container, mountElement, currentElement) {\n  let elementsToExclude = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  let show = arguments.length > 4 ? arguments[4] : undefined;\n  const blacklist = [mountElement, currentElement, ...elementsToExclude];\n  const blacklistTagNames = ['TEMPLATE', 'SCRIPT', 'STYLE'];\n  [].forEach.call(container.children, element => {\n    if (blacklist.indexOf(element) === -1 && blacklistTagNames.indexOf(element.tagName) === -1) {\n      ariaHidden(element, show);\n    }\n  });\n}\n\nfunction findIndexOf(items, callback) {\n  let idx = -1;\n  items.some((item, index) => {\n    if (callback(item)) {\n      idx = index;\n      return true;\n    }\n\n    return false;\n  });\n  return idx;\n}\n\nfunction handleContainer(containerInfo, props) {\n  const restoreStyle = [];\n  const container = containerInfo.container;\n\n  if (!props.disableScrollLock) {\n    if (isOverflowing(container)) {\n      // Compute the size before applying overflow hidden to avoid any scroll jumps.\n      const scrollbarSize = getScrollbarSize(ownerDocument(container));\n      restoreStyle.push({\n        value: container.style.paddingRight,\n        property: 'padding-right',\n        el: container\n      }); // Use computed style, here to get the real padding to add our scrollbar width.\n\n      container.style.paddingRight = `${getPaddingRight(container) + scrollbarSize}px`; // .mui-fixed is a global helper.\n\n      const fixedElements = ownerDocument(container).querySelectorAll('.mui-fixed');\n      [].forEach.call(fixedElements, element => {\n        restoreStyle.push({\n          value: element.style.paddingRight,\n          property: 'padding-right',\n          el: element\n        });\n        element.style.paddingRight = `${getPaddingRight(element) + scrollbarSize}px`;\n      });\n    } // Improve Gatsby support\n    // https://css-tricks.com/snippets/css/force-vertical-scrollbar/\n\n\n    const parent = container.parentElement;\n    const containerWindow = ownerWindow(container);\n    const scrollContainer = (parent == null ? void 0 : parent.nodeName) === 'HTML' && containerWindow.getComputedStyle(parent).overflowY === 'scroll' ? parent : container; // Block the scroll even if no scrollbar is visible to account for mobile keyboard\n    // screensize shrink.\n\n    restoreStyle.push({\n      value: scrollContainer.style.overflow,\n      property: 'overflow',\n      el: scrollContainer\n    }, {\n      value: scrollContainer.style.overflowX,\n      property: 'overflow-x',\n      el: scrollContainer\n    }, {\n      value: scrollContainer.style.overflowY,\n      property: 'overflow-y',\n      el: scrollContainer\n    });\n    scrollContainer.style.overflow = 'hidden';\n  }\n\n  const restore = () => {\n    restoreStyle.forEach(_ref => {\n      let {\n        value,\n        el,\n        property\n      } = _ref;\n\n      if (value) {\n        el.style.setProperty(property, value);\n      } else {\n        el.style.removeProperty(property);\n      }\n    });\n  };\n\n  return restore;\n}\n\nfunction getHiddenSiblings(container) {\n  const hiddenSiblings = [];\n  [].forEach.call(container.children, element => {\n    if (element.getAttribute('aria-hidden') === 'true') {\n      hiddenSiblings.push(element);\n    }\n  });\n  return hiddenSiblings;\n}\n/**\n * @ignore - do not document.\n *\n * Proper state management for containers and the modals in those containers.\n * Simplified, but inspired by react-overlay's ModalManager class.\n * Used by the Modal to ensure proper styling of containers.\n */\n\n\nexport default class ModalManager {\n  constructor() {\n    this.containers = void 0;\n    this.modals = void 0;\n    this.modals = [];\n    this.containers = [];\n  }\n\n  add(modal, container) {\n    let modalIndex = this.modals.indexOf(modal);\n\n    if (modalIndex !== -1) {\n      return modalIndex;\n    }\n\n    modalIndex = this.modals.length;\n    this.modals.push(modal); // If the modal we are adding is already in the DOM.\n\n    if (modal.modalRef) {\n      ariaHidden(modal.modalRef, false);\n    }\n\n    const hiddenSiblings = getHiddenSiblings(container);\n    ariaHiddenSiblings(container, modal.mount, modal.modalRef, hiddenSiblings, true);\n    const containerIndex = findIndexOf(this.containers, item => item.container === container);\n\n    if (containerIndex !== -1) {\n      this.containers[containerIndex].modals.push(modal);\n      return modalIndex;\n    }\n\n    this.containers.push({\n      modals: [modal],\n      container,\n      restore: null,\n      hiddenSiblings\n    });\n    return modalIndex;\n  }\n\n  mount(modal, props) {\n    const containerIndex = findIndexOf(this.containers, item => item.modals.indexOf(modal) !== -1);\n    const containerInfo = this.containers[containerIndex];\n\n    if (!containerInfo.restore) {\n      containerInfo.restore = handleContainer(containerInfo, props);\n    }\n  }\n\n  remove(modal) {\n    const modalIndex = this.modals.indexOf(modal);\n\n    if (modalIndex === -1) {\n      return modalIndex;\n    }\n\n    const containerIndex = findIndexOf(this.containers, item => item.modals.indexOf(modal) !== -1);\n    const containerInfo = this.containers[containerIndex];\n    containerInfo.modals.splice(containerInfo.modals.indexOf(modal), 1);\n    this.modals.splice(modalIndex, 1); // If that was the last modal in a container, clean up the container.\n\n    if (containerInfo.modals.length === 0) {\n      // The modal might be closed before it had the chance to be mounted in the DOM.\n      if (containerInfo.restore) {\n        containerInfo.restore();\n      }\n\n      if (modal.modalRef) {\n        // In case the modal wasn't in the DOM yet.\n        ariaHidden(modal.modalRef, true);\n      }\n\n      ariaHiddenSiblings(containerInfo.container, modal.mount, modal.modalRef, containerInfo.hiddenSiblings, false);\n      this.containers.splice(containerIndex, 1);\n    } else {\n      // Otherwise make sure the next top modal is visible to a screen reader.\n      const nextTop = containerInfo.modals[containerInfo.modals.length - 1]; // as soon as a modal is adding its modalRef is undefined. it can't set\n      // aria-hidden because the dom element doesn't exist either\n      // when modal was unmounted before modalRef gets null\n\n      if (nextTop.modalRef) {\n        ariaHidden(nextTop.modalRef, false);\n      }\n    }\n\n    return modalIndex;\n  }\n\n  isTopModal(modal) {\n    return this.modals.length > 0 && this.modals[this.modals.length - 1] === modal;\n  }\n\n}","map":{"version":3,"sources":["/Users/jonas/Documents/GitHub/OpenArabic/frontend/node_modules/@mui/core/ModalUnstyled/ModalManager.js"],"names":["unstable_ownerWindow","ownerWindow","unstable_ownerDocument","ownerDocument","unstable_getScrollbarSize","getScrollbarSize","isOverflowing","container","doc","body","innerWidth","documentElement","clientWidth","scrollHeight","clientHeight","ariaHidden","element","show","setAttribute","removeAttribute","getPaddingRight","parseInt","getComputedStyle","paddingRight","ariaHiddenSiblings","mountElement","currentElement","elementsToExclude","blacklist","blacklistTagNames","forEach","call","children","indexOf","tagName","findIndexOf","items","callback","idx","some","item","index","handleContainer","containerInfo","props","restoreStyle","disableScrollLock","scrollbarSize","push","value","style","property","el","fixedElements","querySelectorAll","parent","parentElement","containerWindow","scrollContainer","nodeName","overflowY","overflow","overflowX","restore","setProperty","removeProperty","getHiddenSiblings","hiddenSiblings","getAttribute","ModalManager","constructor","containers","modals","add","modal","modalIndex","length","modalRef","mount","containerIndex","remove","splice","nextTop","isTopModal"],"mappings":"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","sourcesContent":["import { unstable_ownerWindow as ownerWindow, unstable_ownerDocument as ownerDocument, unstable_getScrollbarSize as getScrollbarSize } from '@mui/utils';\n\n// Is a vertical scrollbar displayed?\nfunction isOverflowing(container) {\n  const doc = ownerDocument(container);\n\n  if (doc.body === container) {\n    return ownerWindow(container).innerWidth > doc.documentElement.clientWidth;\n  }\n\n  return container.scrollHeight > container.clientHeight;\n}\n\nexport function ariaHidden(element, show) {\n  if (show) {\n    element.setAttribute('aria-hidden', 'true');\n  } else {\n    element.removeAttribute('aria-hidden');\n  }\n}\n\nfunction getPaddingRight(element) {\n  return parseInt(ownerWindow(element).getComputedStyle(element).paddingRight, 10) || 0;\n}\n\nfunction ariaHiddenSiblings(container, mountElement, currentElement, elementsToExclude = [], show) {\n  const blacklist = [mountElement, currentElement, ...elementsToExclude];\n  const blacklistTagNames = ['TEMPLATE', 'SCRIPT', 'STYLE'];\n  [].forEach.call(container.children, element => {\n    if (blacklist.indexOf(element) === -1 && blacklistTagNames.indexOf(element.tagName) === -1) {\n      ariaHidden(element, show);\n    }\n  });\n}\n\nfunction findIndexOf(items, callback) {\n  let idx = -1;\n  items.some((item, index) => {\n    if (callback(item)) {\n      idx = index;\n      return true;\n    }\n\n    return false;\n  });\n  return idx;\n}\n\nfunction handleContainer(containerInfo, props) {\n  const restoreStyle = [];\n  const container = containerInfo.container;\n\n  if (!props.disableScrollLock) {\n    if (isOverflowing(container)) {\n      // Compute the size before applying overflow hidden to avoid any scroll jumps.\n      const scrollbarSize = getScrollbarSize(ownerDocument(container));\n      restoreStyle.push({\n        value: container.style.paddingRight,\n        property: 'padding-right',\n        el: container\n      }); // Use computed style, here to get the real padding to add our scrollbar width.\n\n      container.style.paddingRight = `${getPaddingRight(container) + scrollbarSize}px`; // .mui-fixed is a global helper.\n\n      const fixedElements = ownerDocument(container).querySelectorAll('.mui-fixed');\n      [].forEach.call(fixedElements, element => {\n        restoreStyle.push({\n          value: element.style.paddingRight,\n          property: 'padding-right',\n          el: element\n        });\n        element.style.paddingRight = `${getPaddingRight(element) + scrollbarSize}px`;\n      });\n    } // Improve Gatsby support\n    // https://css-tricks.com/snippets/css/force-vertical-scrollbar/\n\n\n    const parent = container.parentElement;\n    const containerWindow = ownerWindow(container);\n    const scrollContainer = (parent == null ? void 0 : parent.nodeName) === 'HTML' && containerWindow.getComputedStyle(parent).overflowY === 'scroll' ? parent : container; // Block the scroll even if no scrollbar is visible to account for mobile keyboard\n    // screensize shrink.\n\n    restoreStyle.push({\n      value: scrollContainer.style.overflow,\n      property: 'overflow',\n      el: scrollContainer\n    }, {\n      value: scrollContainer.style.overflowX,\n      property: 'overflow-x',\n      el: scrollContainer\n    }, {\n      value: scrollContainer.style.overflowY,\n      property: 'overflow-y',\n      el: scrollContainer\n    });\n    scrollContainer.style.overflow = 'hidden';\n  }\n\n  const restore = () => {\n    restoreStyle.forEach(({\n      value,\n      el,\n      property\n    }) => {\n      if (value) {\n        el.style.setProperty(property, value);\n      } else {\n        el.style.removeProperty(property);\n      }\n    });\n  };\n\n  return restore;\n}\n\nfunction getHiddenSiblings(container) {\n  const hiddenSiblings = [];\n  [].forEach.call(container.children, element => {\n    if (element.getAttribute('aria-hidden') === 'true') {\n      hiddenSiblings.push(element);\n    }\n  });\n  return hiddenSiblings;\n}\n\n/**\n * @ignore - do not document.\n *\n * Proper state management for containers and the modals in those containers.\n * Simplified, but inspired by react-overlay's ModalManager class.\n * Used by the Modal to ensure proper styling of containers.\n */\nexport default class ModalManager {\n  constructor() {\n    this.containers = void 0;\n    this.modals = void 0;\n    this.modals = [];\n    this.containers = [];\n  }\n\n  add(modal, container) {\n    let modalIndex = this.modals.indexOf(modal);\n\n    if (modalIndex !== -1) {\n      return modalIndex;\n    }\n\n    modalIndex = this.modals.length;\n    this.modals.push(modal); // If the modal we are adding is already in the DOM.\n\n    if (modal.modalRef) {\n      ariaHidden(modal.modalRef, false);\n    }\n\n    const hiddenSiblings = getHiddenSiblings(container);\n    ariaHiddenSiblings(container, modal.mount, modal.modalRef, hiddenSiblings, true);\n    const containerIndex = findIndexOf(this.containers, item => item.container === container);\n\n    if (containerIndex !== -1) {\n      this.containers[containerIndex].modals.push(modal);\n      return modalIndex;\n    }\n\n    this.containers.push({\n      modals: [modal],\n      container,\n      restore: null,\n      hiddenSiblings\n    });\n    return modalIndex;\n  }\n\n  mount(modal, props) {\n    const containerIndex = findIndexOf(this.containers, item => item.modals.indexOf(modal) !== -1);\n    const containerInfo = this.containers[containerIndex];\n\n    if (!containerInfo.restore) {\n      containerInfo.restore = handleContainer(containerInfo, props);\n    }\n  }\n\n  remove(modal) {\n    const modalIndex = this.modals.indexOf(modal);\n\n    if (modalIndex === -1) {\n      return modalIndex;\n    }\n\n    const containerIndex = findIndexOf(this.containers, item => item.modals.indexOf(modal) !== -1);\n    const containerInfo = this.containers[containerIndex];\n    containerInfo.modals.splice(containerInfo.modals.indexOf(modal), 1);\n    this.modals.splice(modalIndex, 1); // If that was the last modal in a container, clean up the container.\n\n    if (containerInfo.modals.length === 0) {\n      // The modal might be closed before it had the chance to be mounted in the DOM.\n      if (containerInfo.restore) {\n        containerInfo.restore();\n      }\n\n      if (modal.modalRef) {\n        // In case the modal wasn't in the DOM yet.\n        ariaHidden(modal.modalRef, true);\n      }\n\n      ariaHiddenSiblings(containerInfo.container, modal.mount, modal.modalRef, containerInfo.hiddenSiblings, false);\n      this.containers.splice(containerIndex, 1);\n    } else {\n      // Otherwise make sure the next top modal is visible to a screen reader.\n      const nextTop = containerInfo.modals[containerInfo.modals.length - 1]; // as soon as a modal is adding its modalRef is undefined. it can't set\n      // aria-hidden because the dom element doesn't exist either\n      // when modal was unmounted before modalRef gets null\n\n      if (nextTop.modalRef) {\n        ariaHidden(nextTop.modalRef, false);\n      }\n    }\n\n    return modalIndex;\n  }\n\n  isTopModal(modal) {\n    return this.modals.length > 0 && this.modals[this.modals.length - 1] === modal;\n  }\n\n}"]},"metadata":{},"sourceType":"module"}